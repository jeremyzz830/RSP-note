<h1 align="center"> SYSTEM PROGRAMMING WEEK 11 </h1>
<h2 align="center"> ROS Control </h2>
<h5 align="right"> -- by Jeremy Zhang @ Johns Hopkins University</h5>

[TOC]

# I. Introduction

[http://wiki.ros.org/ros_control](http://wiki.ros.org/ros_control)

Two Basic car models:

[Ackerman](https://en.wikipedia.org/wiki/Ackermann_steering_geometry): has a steering angle, robot turns through steering the wheel 

[Husky](http://wiki.ros.org/Robots/Husky) : only turns through the different rotational direction of the two wheels 



## About ros_control

We encourage you to read an overview of the documentation on [ros_control](http://ros.org/wiki/ros_control) before proceeding.

## Data flow of ros_control and Gazebo

Simulating a robot's controllers in Gazebo can be accomplished using ros_control and a simple Gazebo plugin adapter. An overview of the relationship between simulation, hardware, controllers and transmissions is shown below:

![img](https://github.com/osrf/gazebo_tutorials/raw/master/ros_control/Gazebo_ros_transmission.png)

## Prerequisites

This tutorial builds off of many of the concepts in the previous tutorials. We will again be using the RRBot that was setup in the [Using URDF in Gazebo](http://gazebosim.org/tutorials/?tut=ros_urdf) tutorial, as an example for the plugins covered here.

Make sure you have already installed ros_control, ros_controllers, and their dependencies as described in the [installation instructions](http://gazebosim.org/tutorials?tut=ros_installing&cat=connect_ros).



## Usage : Add transmission elements to a URDF

To use ros_control with your robot, you need to add some additional elements to your URDF. The `<transmission>` element is used to link actuators to joints, see the [`` spec](http://ros.org/wiki/urdf/XML/Transmission) for exact XML format.

For the purposes of gazebo_ros_control in its current implementation, the only important information in these transmission tags are:

- `<joint name="">` - the name must correspond to a joint else where in your URDF
- `<type>` - the type of transmission. Currently only "transmission_interface/SimpleTransmission" is implemented. (feel free to add more)
- `<hardwareInterface>` - within the `<actuator>` and `<joint>` tags, this tells the gazebo_ros_control plugin what hardware interface to load (position, velocity or effort interfaces). Currently only effort interfaces are implemented. (feel free to add more)

The rest of the names and elements are currently ignored.



## Overview

The ros_control packages are a rewrite of the [pr2_mechanism](http://wiki.ros.org/pr2_mechanism) packages to make controllers generic to all robots beyond just the PR2. 

![ros control](http://wiki.ros.org/ros_control?action=AttachFile&do=get&target=gazebo_ros_control.png) 

*Diagram source in ros_control/documentation* 

The ros_control packages takes as input the joint state data from your  robot's actuator's encoders and an input set point. It uses a generic  control loop feedback mechanism, typically a PID controller, to control  the output, typically effort, sent to your actuators. ros_control gets  more complicated for physical mechanisms that do not have one-to-one  mappings of joint positions, efforts, etc but these scenarios are  accounted for using transmissions. 

A high-level overview of the project can be found in the ROScon 2014 talk entitled *ros_control: An overview* ([slides](http://roscon.ros.org/2014/wp-content/uploads/2014/07/ros_control_an_overview.pdf), [video](https://vimeo.com/107507546)). 

A short summary of CombinedRobotHW can be found in [this](https://vimeo.com/187696094) ROScon 2016 talk. 

Additional documentation is available at the [Github Wiki](https://github.com/ros-controls/ros_control/wiki)



## SO, the KEY of ros control is ...

To enable the user to apply whatever controller to either simulation in gazebo and real experiment on real robot. All the control command generated by the user will first pass through a so called Hardware Interface and then hardware interface will send that command to simulation enviroment or real robot.



## Yaml

yaml file is generally used to define through which topic the control commands are sent.



Parse the launch file to check what are loaded in ~/rsp_workspace/src/fmauch_universal_robot/ur_description/launch/load_ur5.launch 

```xml	
<?xml version="1.0"?>
<launch>
  <!--ur5 parameters files -->
  <arg name="joint_limit_params" default="$(find ur_description)/config/ur5/join
t_limits.yaml"/>
  <arg name="kinematics_params" default="$(find ur_description)/config/ur5/defau
lt_kinematics.yaml"/>
  <arg name="physical_params" default="$(find ur_description)/config/ur5/physica
l_parameters.yaml"/>
  <arg name="visual_params" default="$(find ur_description)/config/ur5/visual_pa
rameters.yaml"/>
  <!--common parameters -->
  <arg name="transmission_hw_interface" default="hardware_interface/PositionJoin
tInterface" />
  <arg name="safety_limits" default="false" doc="If True, enable the safety limi
ts controller"/>
  <arg name="safety_pos_margin" default="0.15" doc="The lower/upper limits in th
e safety controller" />
  <arg name="safety_k_position" default="20" doc="Used to set k position in the 
safety controller" />

  <!-- use common launch file and pass all arguments to it -->
  <include file="$(find ur_description)/launch/load_ur.launch" pass_all_args="tr
ue"/>
</launch>
```

you can see that there is a hardware interface tag:

  <arg name="transmission_hw_interface" default="hardware_interface/PositionJoin
tInterface" />



Most of the robot only allows to control through position and velocity. Few robot support control directly through joint torque.

all controllers proveide by ros control are in the following:

## Controllers



A list of available controller plugins, contained in [ros_controllers](http://wiki.ros.org/ros_controllers), as of this writing. You can of course create your own and are not limited to the below list. 

- [joint_state_controller](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/joint_state_controller/include/joint_state_controller) - Publishes the state of all resources registered to a hardware_interface::[JointStateInterface](http://wiki.ros.org/JointStateInterface) to a topic of type [sensor_msgs/JointState](http://docs.ros.org/melodic/api/sensor_msgs/html/msg/JointState.html). 
  - joint_state_controller 
- [position_controllers](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/position_controllers/include/position_controllers) - Command a desired position to the [HardwareInterface](http://wiki.ros.org/HardwareInterface). 
  - joint_position_controller - Receives a position input and sends a position output, just transferring the input with the [forward_command_controller](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/forward_command_controller).  
  - joint_group_position_controller - Set multiple joint positions at once. 
- [velocity_controllers](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/velocity_controllers/include/velocity_controllers) - Command a desired velocity to the [HardwareInterface](http://wiki.ros.org/HardwareInterface). 
  - joint_position_controller - Receives a position input and sends a velocity output, using a PID controller. 
  - joint_velocity_controller - Receives a velocity input and sends a velocity output, just transferring the input with the [forward_command_controller](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/forward_command_controller).  
  - joint_group_velocity_controller - Set multiple joint velocities at once. 
- [effort_controllers](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/effort_controllers/include/effort_controllers) - Command a desired effort(force/torque) to the Hardware Interface. 
  - joint_position_controller - Receives a position input and sends an effort output, using a PID controller.  
  - joint_group_position_controller - Set multiple joint positions at once. 
  - joint_velocity_controller - Receives a velocity input and sends an effort output, using a PID controller.  
  - joint_effort_controller - Receives an effort input and sends an effort output, just transferring the input with the [forward_command_controller](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/forward_command_controller).  
  - joint_group_effort_controller - Set multiple joint efforts at once. 
- [joint_trajectory_controllers](https://github.com/ros-controls/ros_controllers/tree/melodic-devel/joint_trajectory_controller) - Extra functionality for splining an entire trajectory. Take a look at the [source file](https://github.com/ros-controls/ros_controllers/blob/melodic-devel/joint_trajectory_controller/src/joint_trajectory_controller.cpp) to understand how the joint_trajectory_controller is namespaced with the position_controller, velocity_controller, etc. 
  - position_controller 
  - velocity_controller 
  - effort_controller 
  - position_velocity_controller 
  - position_velocity_acceleration_controller 





# II. Create your own controllers

## 2.1 controllers.yaml

you can put all the controllers description into single yaml file. You can also put them into seperate files

joint_state_controller.yaml

```yaml
joint_state_controller:
        type: joint_state_controller/JointStateController
        publish_rate: 100
```

 Trajectory controller indicates you precalculate everything and the robot will follows you control input. Whereas the group controller allows you to control through different ways like telelop ...



position_controller.yaml

```yaml
joint_group_position_controller:
        type: position_controllers/JointGroupPositionController
        joints:
          - shoulder_pan_joint
          - shoulder_lift_joint
          - elbow_joint
          - wrist_1_joint
          - wrist_2_joint
          - wrist_3_joint
```



velocity_controller.yaml

```yaml
joint_group_velocity_controller:
        type: velocity_controllers/JointGroupVelocityController
        joints:
          - shoulder_pan_joint
          - shoulder_lift_joint
          - elbow_joint
          - wrist_1_joint
          - wrist_2_joint
          - wrist_3_joint
```

These three files defines three different controllers. You can choose to use which at launch time.





## 2.2 launch the controller manager

ur5.launch

```xml
<launch>
    <arg name="interface" default="Velocity" /> 
    <!-- this arg means by default we are not using velocity to control -->
    
    <include file="$(find gazebo_ros)/launch/empty_world.launch">
        <arg name="world_name" default="worlds/empty.world" />
    </include>

    <include file="$(find ur_description)/launch/load_ur5.launch">
        <arg name="transmission_hw_interface" default="hardware_interface/$(arg interface)JointInterface" />
        <!-- it's a good habit of only creating a hardware interface at a time -->
    </include>
    <!-- through this inlcude, you can launch whichever controller you want -->
    

    <node   pkg="gazebo_ros" 
            type="spawn_model" 
            name="spawn_model" 
            args="-urdf -param robot_description -model robot -z 0.1" 
            output="screen" />

    <rosparam command="load" file="$(find ur_velocity_interface)/controllers/joint_state_controller.yaml" />
    <!-- this command will pick up the controller yaml and load it to the parameter server, but not start it -->
    <node   pkg="controller_manager"
            type="controller_manager"
            name="joint_state_controller_spawner"
            args="spawn joint_state_controller"
            output="screen" />
    <!-- this node will go fetch the controller that has been upload to parameter server and spawn a cotroller to start it-->
    
    <rosparam command="load" file="$(find ur_velocity_interface)/controllers/velocity_controller.yaml" />
    <node   pkg="controller_manager"
            type="controller_manager"
            name="velocity_controller_spawner"
            args="spawn joint_group_velocity_controller"
            output="screen" />
    <!-- this will start a spawner of joint group velocity controller -->

    <rosparam command="load" file="$(find ur_velocity_interface)/controllers/position_controller.yaml" />
    <node   pkg="controller_manager"
            type="controller_manager"
            name="position_controller_spawner"
            args="spawn joint_group_position_controller"
            output="screen" />    


</launch>
```

You can see that we load 3 different controllers here. If they are loaded at the same time, manager will crush. It only allows to load one controller at a time. 

In our case, we only have one hardware interface, so we are only gonna start one controller, which is velocity.
